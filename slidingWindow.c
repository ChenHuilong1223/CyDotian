#define _CRT_SECURE_NO_WARNINGS 1
#pragma warning(disable:4267)
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include "slidingWindow.h"

int aaFindMatrixIndex(char c)
{
	switch (c)
	{
	case 'A':
		return 0;
		break;
	case 'R':
		return 1;
		break;
	case 'N':
		return 2;
		break;
	case 'D':
		return 3;
		break;
	case 'C':
		return 4;
		break;
	case 'Q':
		return 5;
		break;
	case 'E':
		return 6;
		break;
	case 'G':
		return 7;
		break;
	case 'H':
		return 8;
		break;
	case 'I':
		return 9;
		break;
	case 'L':
		return 10;
		break;
	case 'K':
		return 11;
		break;
	case 'M':
		return 12;
		break;
	case 'F':
		return 13;
		break;
	case 'P':
		return 14;
		break;
	case 'S':
		return 15;
		break;
	case 'T':
		return 16;
		break;
	case 'W':
		return 17;
		break;
	case 'Y':
		return 18;
		break;
	case 'V':
		return 19;
		break;
	case 'B':
		return 20;
		break;
	case 'Z':
		return 21;
		break;
	case 'X':
		return 22;
		break;
	case '*':
		return 23;
		break;
	default:
		return -1;
		break;
	}
}
int aaNonExactMatch(char a, char b, int matrix)
{
	int i, j;
	switch (matrix)
	{
	case 0:
	{
		int BLOSUM45[24][24] = {
		5,-2,-1,-2,-1,-1,-1,0,-2,-1,-1,-1,-1,-2,-1,1,0,-2,-2,0,-1,-1,-1,-5,
		-2,7,0,-1,-3,1,0,-2,0,-3,-2,3,-1,-2,-2,-1,-1,-2,-1,-2,-1,1,-1,-5,
		-1,0,6,2,-2,0,0,0,1,-2,-3,0,-2,-2,-2,1,0,-4,-2,-3,5,0,-1,-5,
		-2,-1,2,7,-3,0,2,-1,0,-4,-3,0,-3,-4,-1,0,-1,-4,-2,-3,6,1,-1,-5,
		-1,-3,-2,-3,12,-3,-3,-3,-3,-3,-2,-3,-2,-2,-4,-1,-1,-5,-3,-1,-2,-3,-1,-5,
		-1,1,0,0,-3,6,2,-2,1,-2,-2,1,0,-4,-1,0,-1,-2,-1,-3,0,4,-1,-5,
		-1,0,0,2,-3,2,6,-2,0,-3,-2,1,-2,-3,0,0,-1,-3,-2,-3,1,5,-1,-5,
		0,-2,0,-1,-3,-2,-2,7,-2,-4,-3,-2,-2,-3,-2,0,-2,-2,-3,-3,-1,-2,-1,-5,
		-2,0,1,0,-3,1,0,-2,10,-3,-2,-1,0,-2,-2,-1,-2,-3,2,-3,0,0,-1,-5,
		-1,-3,-2,-4,-3,-2,-3,-4,-3,5,2,-3,2,0,-2,-2,-1,-2,0,3,-3,-3,-1,-5,
		-1,-2,-3,-3,-2,-2,-2,-3,-2,2,5,-3,2,1,-3,-3,-1,-2,0,1,-3,-2,-1,-5,
		-1,3,0,0,-3,1,1,-2,-1,-3,-3,5,-1,-3,-1,-1,-1,-2,-1,-2,0,1,-1,-5,
		-1,-1,-2,-3,-2,0,-2,-2,0,2,2,-1,6,0,-2,-2,-1,-2,0,1,-2,-1,-1,-5,
		-2,-2,-2,-4,-2,-4,-3,-3,-2,0,1,-3,0,8,-3,-2,-1,1,3,0,-3,-3,-1,-5,
		-1,-2,-2,-1,-4,-1,0,-2,-2,-2,-3,-1,-2,-3,9,-1,-1,-3,-3,-3,-2,-1,-1,-5,
		1,-1,1,0,-1,0,0,0,-1,-2,-3,-1,-2,-2,-1,4,2,-4,-2,-1,0,0,-1,-5,
		0,-1,0,-1,-1,-1,-1,-2,-2,-1,-1,-1,-1,-1,-1,2,5,-3,-1,0,0,-1,-1,-5,
		-2,-2,-4,-4,-5,-2,-3,-2,-3,-2,-2,-2,-2,1,-3,-4,-3,15,3,-3,-4,-2,-1,-5,
		-2,-1,-2,-2,-3,-1,-2,-3,2,0,0,-1,0,3,-3,-2,-1,3,8,-1,-2,-2,-1,-5,
		0,-2,-3,-3,-1,-3,-3,-3,-3,3,1,-2,1,0,-3,-1,0,-3,-1,5,-3,-3,-1,-5,
		-1,-1,5,6,-2,0,1,-1,0,-3,-3,0,-2,-3,-2,0,0,-4,-2,-3,5,1,-1,-5,
		-1,1,0,1,-3,4,5,-2,0,-3,-2,1,-1,-3,-1,0,-1,-2,-2,-3,1,5,-1,-5,
		-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-5,
		-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,1
		};
		i = aaFindMatrixIndex(a);
		j = aaFindMatrixIndex(b);
		return BLOSUM45[i][j];
		break;
	}
	case 1:
	{
		int BLOSUM62[24][24] = {
		4,-1,-2,-2,0,-1,-1,0,-2,-1,-1,-1,-1,-2,-1,1,0,-3,-2,0,-2,-1,0,-4,
		-1,5,0,-2,-3,1,0,-2,0,-3,-2,2,-1,-3,-2,-1,-1,-3,-2,-3,-1,0,-1,-4,
		-2,0,6,1,-3,0,0,0,1,-3,-3,0,-2,-3,-2,1,0,-4,-2,-3,3,0,-1,-4,
		-2,-2,1,6,-3,0,2,-1,-1,-3,-4,-1,-3,-3,-1,0,-1,-4,-3,-3,4,1,-1,-4,
		0,-3,-3,-3,9,-3,-4,-3,-3,-1,-1,-3,-1,-2,-3,-1,-1,-2,-2,-1,-3,-3,-2,-4,
		-1,1,0,0,-3,5,2,-2,0,-3,-2,1,0,-3,-1,0,-1,-2,-1,-2,0,3,-1,-4,
		-1,0,0,2,-4,2,5,-2,0,-3,-3,1,-2,-3,-1,0,-1,-3,-2,-2,1,4,-1,-4,
		0,-2,0,-1,-3,-2,-2,6,-2,-4,-4,-2,-3,-3,-2,0,-2,-2,-3,-3,-1,-2,-1,-4,
		-2,0,1,-1,-3,0,0,-2,8,-3,-3,-1,-2,-1,-2,-1,-2,-2,2,-3,0,0,-1,-4,
		-1,-3,-3,-3,-1,-3,-3,-4,-3,4,2,-3,1,0,-3,-2,-1,-3,-1,3,-3,-3,-1,-4,
		-1,-2,-3,-4,-1,-2,-3,-4,-3,2,4,-2,2,0,-3,-2,-1,-2,-1,1,-4,-3,-1,-4,
		-1,2,0,-1,-3,1,1,-2,-1,-3,-2,5,-1,-3,-1,0,-1,-3,-2,-2,0,1,-1,-4,
		-1,-1,-2,-3,-1,0,-2,-3,-2,1,2,-1,5,0,-2,-1,-1,-1,-1,1,-3,-1,-1,-4,
		-2,-3,-3,-3,-2,-3,-3,-3,-1,0,0,-3,0,6,-4,-2,-2,1,3,-1,-3,-3,-1,-4,
		-1,-2,-2,-1,-3,-1,-1,-2,-2,-3,-3,-1,-2,-4,7,-1,-1,-4,-3,-2,-2,-1,-2,-4,
		1,-1,1,0,-1,0,0,0,-1,-2,-2,0,-1,-2,-1,4,1,-3,-2,-2,0,0,0,-4,
		0,-1,0,-1,-1,-1,-1,-2,-2,-1,-1,-1,-1,-2,-1,1,5,-2,-2,0,-1,-1,0,-4,
		-3,-3,-4,-4,-2,-2,-3,-2,-2,-3,-2,-3,-1,1,-4,-3,-2,11,2,-3,-4,-3,-2,-4,
		-2,-2,-2,-3,-2,-1,-2,-3,2,-1,-1,-2,-1,3,-3,-2,-2,2,7,-1,-3,-2,-1,-4,
		0,-3,-3,-3,-1,-2,-2,-3,-3,3,1,-2,1,-1,-2,-2,0,-3,-1,4,-3,-2,-1,-4,
		-2,-1,3,4,-3,0,1,-1,0,-3,-4,0,-3,-3,-2,0,-1,-4,-3,-3,4,1,-1,-4,
		-1,0,0,1,-3,3,4,-2,0,-3,-3,1,-1,-3,-1,0,-1,-3,-2,-2,1,4,-1,-4,
		0,-1,-1,-1,-2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-2,0,0,-2,-1,-1,-1,-1,-1,-4,
		-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,1,
		};
		i = aaFindMatrixIndex(a);
		j = aaFindMatrixIndex(b);
		return BLOSUM62[i][j];
		break;
	}
	case 2:
	{
		int BLOSUM80[24][24] = {
		5,-2,-2,-2,-1,-1,-1,0,-2,-2,-2,-1,-1,-3,-1,1,0,-3,-2,0,-2,-1,-1,-6,
		-2,6,-1,-2,-4,1,-1,-3,0,-3,-3,2,-2,-4,-2,-1,-1,-4,-3,-3,-1,0,-1,-6,
		-2,-1,6,1,-3,0,-1,-1,0,-4,-4,0,-3,-4,-3,0,0,-4,-3,-4,5,0,-1,-6,
		-2,-2,1,6,-4,-1,1,-2,-2,-4,-5,-1,-4,-4,-2,-1,-1,-6,-4,-4,5,1,-1,-6,
		-1,-4,-3,-4,9,-4,-5,-4,-4,-2,-2,-4,-2,-3,-4,-2,-1,-3,-3,-1,-4,-4,-1,-6,
		-1,1,0,-1,-4,6,2,-2,1,-3,-3,1,0,-4,-2,0,-1,-3,-2,-3,0,4,-1,-6,
		-1,-1,-1,1,-5,2,6,-3,0,-4,-4,1,-2,-4,-2,0,-1,-4,-3,-3,1,5,-1,-6,
		0,-3,-1,-2,-4,-2,-3,6,-3,-5,-4,-2,-4,-4,-3,-1,-2,-4,-4,-4,-1,-3,-1,-6,
		-2,0,0,-2,-4,1,0,-3,8,-4,-3,-1,-2,-2,-3,-1,-2,-3,2,-4,-1,0,-1,-6,
		-2,-3,-4,-4,-2,-3,-4,-5,-4,5,1,-3,1,-1,-4,-3,-1,-3,-2,3,-4,-4,-1,-6,
		-2,-3,-4,-5,-2,-3,-4,-4,-3,1,4,-3,2,0,-3,-3,-2,-2,-2,1,-4,-3,-1,-6,
		-1,2,0,-1,-4,1,1,-2,-1,-3,-3,5,-2,-4,-1,-1,-1,-4,-3,-3,-1,1,-1,-6,
		-1,-2,-3,-4,-2,0,-2,-4,-2,1,2,-2,6,0,-3,-2,-1,-2,-2,1,-3,-1,-1,-6,
		-3,-4,-4,-4,-3,-4,-4,-4,-2,-1,0,-4,0,6,-4,-3,-2,0,3,-1,-4,-4,-1,-6,
		-1,-2,-3,-2,-4,-2,-2,-3,-3,-4,-3,-1,-3,-4,8,-1,-2,-5,-4,-3,-2,-2,-1,-6,
		1,-1,0,-1,-2,0,0,-1,-1,-3,-3,-1,-2,-3,-1,5,1,-4,-2,-2,0,0,-1,-6,
		0,-1,0,-1,-1,-1,-1,-2,-2,-1,-2,-1,-1,-2,-2,1,5,-4,-2,0,-1,-1,-1,-6,
		-3,-4,-4,-6,-3,-3,-4,-4,-3,-3,-2,-4,-2,0,-5,-4,-4,11,2,-3,-5,-3,-1,-6,
		-2,-3,-3,-4,-3,-2,-3,-4,2,-2,-2,-3,-2,3,-4,-2,-2,2,7,-2,-3,-3,-1,-6,
		0,-3,-4,-4,-1,-3,-3,-4,-4,3,1,-3,1,-1,-3,-2,0,-3,-2,4,-4,-3,-1,-6,
		-2,-1,5,5,-4,0,1,-1,-1,-4,-4,-1,-3,-4,-2,0,-1,-5,-3,-4,5,0,-1,-6,
		-1,0,0,1,-4,4,5,-3,0,-4,-3,1,-1,-4,-2,0,-1,-3,-3,-3,0,5,-1,-6,
		-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-6,
		-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,1
		};
		i = aaFindMatrixIndex(a);
		j = aaFindMatrixIndex(b);
		return BLOSUM80[i][j];
		break;
	}
	case 3:
	{
		int BLOSUM90[24][24] = {
		5,-2,-2,-3,-1,-1,-1,0,-2,-2,-2,-1,-2,-3,-1,1,0,-4,-3,-1,-2,-1,-1,-6,
		-2,6,-1,-3,-5,1,-1,-3,0,-4,-3,2,-2,-4,-3,-1,-2,-4,-3,-3,-2,0,-1,-6,
		-2,-1,7,1,-4,0,-1,-1,0,-4,-4,0,-3,-4,-3,0,0,-5,-3,-4,5,-1,-1,-6,
		-3,-3,1,7,-5,-1,1,-2,-2,-5,-5,-1,-4,-5,-3,-1,-2,-6,-4,-5,5,1,-1,-6,
		-1,-5,-4,-5,9,-4,-6,-4,-5,-2,-2,-4,-2,-3,-4,-2,-2,-4,-4,-2,-4,-5,-1,-6,
		-1,1,0,-1,-4,7,2,-3,1,-4,-3,1,0,-4,-2,-1,-1,-3,-3,-3,-1,5,-1,-6,
		-1,-1,-1,1,-6,2,6,-3,-1,-4,-4,0,-3,-5,-2,-1,-1,-5,-4,-3,1,5,-1,-6,
		0,-3,-1,-2,-4,-3,-3,6,-3,-5,-5,-2,-4,-5,-3,-1,-3,-4,-5,-5,-2,-3,-1,-6,
		-2,0,0,-2,-5,1,-1,-3,8,-4,-4,-1,-3,-2,-3,-2,-2,-3,1,-4,-1,0,-1,-6,
		-2,-4,-4,-5,-2,-4,-4,-5,-4,5,1,-4,1,-1,-4,-3,-1,-4,-2,3,-5,-4,-1,-6,
		-2,-3,-4,-5,-2,-3,-4,-5,-4,1,5,-3,2,0,-4,-3,-2,-3,-2,0,-5,-4,-1,-6,
		-1,2,0,-1,-4,1,0,-2,-1,-4,-3,6,-2,-4,-2,-1,-1,-5,-3,-3,-1,1,-1,-6,
		-2,-2,-3,-4,-2,0,-3,-4,-3,1,2,-2,7,-1,-3,-2,-1,-2,-2,0,-4,-2,-1,-6,
		-3,-4,-4,-5,-3,-4,-5,-5,-2,-1,0,-4,-1,7,-4,-3,-3,0,3,-2,-4,-4,-1,-6,
		-1,-3,-3,-3,-4,-2,-2,-3,-3,-4,-4,-2,-3,-4,8,-2,-2,-5,-4,-3,-3,-2,-1,-6,
		1,-1,0,-1,-2,-1,-1,-1,-2,-3,-3,-1,-2,-3,-2,5,1,-4,-3,-2,0,-1,-1,-6,
		0,-2,0,-2,-2,-1,-1,-3,-2,-1,-2,-1,-1,-3,-2,1,6,-4,-2,-1,-1,-1,-1,-6,
		-4,-4,-5,-6,-4,-3,-5,-4,-3,-4,-3,-5,-2,0,-5,-4,-4,11,2,-3,-6,-4,-1,-6,
		-3,-3,-3,-4,-4,-3,-4,-5,1,-2,-2,-3,-2,3,-4,-3,-2,2,8,-3,-4,-3,-1,-6,
		-1,-3,-4,-5,-2,-3,-3,-5,-4,3,0,-3,0,-2,-3,-2,-1,-3,-3,5,-4,-3,-1,-6,
		-2,-2,5,5,-4,-1,1,-2,-1,-5,-5,-1,-4,-4,-3,0,-1,-6,-4,-4,5,0,-1,-6,
		-1,0,-1,1,-5,5,5,-3,0,-4,-4,1,-2,-4,-2,-1,-1,-4,-3,-3,0,5,-1,-6,
		-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-6,
		-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,1
		};
		i = aaFindMatrixIndex(a);
		j = aaFindMatrixIndex(b);
		return BLOSUM90[i][j];
		break;
	}
	case 4:
	{
		int PAM30[24][24] = {
		6,-7,-4,-3,-6,-4,-2,-2,-7,-5,-6,-7,-5,-8,-2,0,-1,-13,-8,-2,-3,-3,-1,-17,
		-7,8,-6,-10,-8,-2,-9,-9,-2,-5,-8,0,-4,-9,-4,-3,-6,-2,-10,-8,-7,-4,-1,-17,
		-4,-6,8,2,-11,-3,-2,-3,0,-5,-7,-1,-9,-9,-6,0,-2,-8,-4,-8,6,-3,-1,-17,
		-3,-10,2,8,-14,-2,2,-3,-4,-7,-12,-4,-11,-15,-8,-4,-5,-15,-11,-8,6,1,-1,-17,
		-6,-8,-11,-14,10,-14,-14,-9,-7,-6,-15,-14,-13,-13,-8,-3,-8,-15,-4,-6,-12,-14,-1,-17,
		-4,-2,-3,-2,-14,8,1,-7,1,-8,-5,-3,-4,-13,-3,-5,-5,-13,-12,-7,-3,6,-1,-17,
		-2,-9,-2,2,-14,1,8,-4,-5,-5,-9,-4,-7,-14,-5,-4,-6,-17,-8,-6,1,6,-1,-17,
		-2,-9,-3,-3,-9,-7,-4,6,-9,-11,-10,-7,-8,-9,-6,-2,-6,-15,-14,-5,-3,-5,-1,-17,
		-7,-2,0,-4,-7,1,-5,-9,9,-9,-6,-6,-10,-6,-4,-6,-7,-7,-3,-6,-1,-1,-1,-17,
		-5,-5,-5,-7,-6,-8,-5,-11,-9,8,-1,-6,-1,-2,-8,-7,-2,-14,-6,2,-6,-6,-1,-17,
		-6,-8,-7,-12,-15,-5,-9,-10,-6,-1,7,-8,1,-3,-7,-8,-7,-6,-7,-2,-9,-7,-1,-17,
		-7,0,-1,-4,-14,-3,-4,-7,-6,-6,-8,7,-2,-14,-6,-4,-3,-12,-9,-9,-2,-4,-1,-17,
		-5,-4,-9,-11,-13,-4,-7,-8,-10,-1,1,-2,11,-4,-8,-5,-4,-13,-11,-1,-10,-5,-1,-17,
		-8,-9,-9,-15,-13,-13,-14,-9,-6,-2,-3,-14,-4,9,-10,-6,-9,-4,2,-8,-10,-13,-1,-17,
		-2,-4,-6,-8,-8,-3,-5,-6,-4,-8,-7,-6,-8,-10,8,-2,-4,-14,-13,-6,-7,-4,-1,-17,
		0,-3,0,-4,-3,-5,-4,-2,-6,-7,-8,-4,-5,-6,-2,6,0,-5,-7,-6,-1,-5,-1,-17,
		-1,-6,-2,-5,-8,-5,-6,-6,-7,-2,-7,-3,-4,-9,-4,0,7,-13,-6,-3,-3,-6,-1,-17,
		-13,-2,-8,-15,-15,-13,-17,-15,-7,-14,-6,-12,-13,-4,-14,-5,-13,13,-5,-15,-10,-14,-1,-17,
		-8,-10,-4,-11,-4,-12,-8,-14,-3,-6,-7,-9,-11,2,-13,-7,-6,-5,10,-7,-6,-9,-1,-17,
		-2,-8,-8,-8,-6,-7,-6,-5,-6,2,-2,-9,-1,-8,-6,-6,-3,-15,-7,7,-8,-6,-1,-17,
		-3,-7,6,6,-12,-3,1,-3,-1,-6,-9,-2,-10,-10,-7,-1,-3,-10,-6,-8,6,0,-1,-17,
		-3,-4,-3,1,-14,6,6,-5,-1,-6,-7,-4,-5,-13,-4,-5,-6,-14,-9,-6,0,6,-1,-17,
		-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-17,
		-17,-17,-17,-17,-17,-17,-17,-17,-17,-17,-17,-17,-17,-17,-17,-17,-17,-17,-17,-17,-17,-17,-17,1
		};
		i = aaFindMatrixIndex(a);
		j = aaFindMatrixIndex(b);
		return PAM30[i][j];
		break;
	}
	case 5:
	{
		int PAM70[24][24] = {
		5,-4,-2,-1,-4,-2,-1,0,-4,-2,-4,-4,-3,-6,0,1,1,-9,-5,-1,-1,-1,-1,-11,
		-4,8,-3,-6,-5,0,-5,-6,0,-3,-6,2,-2,-7,-2,-1,-4,0,-7,-5,-4,-2,-1,-11,
		-2,-3,6,3,-7,-1,0,-1,1,-3,-5,0,-5,-6,-3,1,0,-6,-3,-5,5,-1,-1,-11,
		-1,-6,3,6,-9,0,3,-1,-1,-5,-8,-2,-7,-10,-4,-1,-2,-10,-7,-5,5,2,-1,-11,
		-4,-5,-7,-9,9,-9,-9,-6,-5,-4,-10,-9,-9,-8,-5,-1,-5,-11,-2,-4,-8,-9,-1,-11,
		-2,0,-1,0,-9,7,2,-4,2,-5,-3,-1,-2,-9,-1,-3,-3,-8,-8,-4,-1,5,-1,-11,
		-1,-5,0,3,-9,2,6,-2,-2,-4,-6,-2,-4,-9,-3,-2,-3,-11,-6,-4,2,5,-1,-11,
		0,-6,-1,-1,-6,-4,-2,6,-6,-6,-7,-5,-6,-7,-3,0,-3,-10,-9,-3,-1,-3,-1,-11,
		-4,0,1,-1,-5,2,-2,-6,8,-6,-4,-3,-6,-4,-2,-3,-4,-5,-1,-4,0,1,-1,-11,
		-2,-3,-3,-5,-4,-5,-4,-6,-6,7,1,-4,1,0,-5,-4,-1,-9,-4,3,-4,-4,-1,-11,
		-4,-6,-5,-8,-10,-3,-6,-7,-4,1,6,-5,2,-1,-5,-6,-4,-4,-4,0,-6,-4,-1,-11,
		-4,2,0,-2,-9,-1,-2,-5,-3,-4,-5,6,0,-9,-4,-2,-1,-7,-7,-6,-1,-2,-1,-11,
		-3,-2,-5,-7,-9,-2,-4,-6,-6,1,2,0,10,-2,-5,-3,-2,-8,-7,0,-6,-3,-1,-11,
		-6,-7,-6,-10,-8,-9,-9,-7,-4,0,-1,-9,-2,8,-7,-4,-6,-2,4,-5,-7,-9,-1,-11,
		0,-2,-3,-4,-5,-1,-3,-3,-2,-5,-5,-4,-5,-7,7,0,-2,-9,-9,-3,-4,-2,-1,-11,
		1,-1,1,-1,-1,-3,-2,0,-3,-4,-6,-2,-3,-4,0,5,2,-3,-5,-3,0,-2,-1,-11,
		1,-4,0,-2,-5,-3,-3,-3,-4,-1,-4,-1,-2,-6,-2,2,6,-8,-4,-1,-1,-3,-1,-11,
		-9,0,-6,-10,-11,-8,-11,-10,-5,-9,-4,-7,-8,-2,-9,-3,-8,13,-3,-10,-7,-10,-1,-11,
		-5,-7,-3,-7,-2,-8,-6,-9,-1,-4,-4,-7,-7,4,-9,-5,-4,-3,9,-5,-4,-7,-1,-11,
		-1,-5,-5,-5,-4,-4,-4,-3,-4,3,0,-6,0,-5,-3,-3,-1,-10,-5,6,-5,-4,-1,-11,
		-1,-4,5,5,-8,-1,2,-1,0,-4,-6,-1,-6,-7,-4,0,-1,-7,-4,-5,5,1,-1,-11,
		-1,-2,-1,2,-9,5,5,-3,1,-4,-4,-2,-3,-9,-2,-2,-3,-10,-7,-4,1,5,-1,-11,
		-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-11,
		-11,-11,-11,-11,-11,-11,-11,-11,-11,-11,-11,-11,-11,-11,-11,-11,-11,-11,-11,-11,-11,-11,-11,1
		};
		i = aaFindMatrixIndex(a);
		j = aaFindMatrixIndex(b);
		return PAM70[i][j];
		break;
	}
	case 6:
	{
		int PAM250[24][24] = {
		2,-2,0,0,-2,0,0,1,-1,-1,-2,-1,-1,-3,1,1,1,-6,-3,0,0,0,-1,-8,
		-2,6,0,-1,-4,1,-1,-3,2,-2,-3,3,0,-4,0,0,-1,2,-4,-2,-1,0,-1,-8,
		0,0,2,2,-4,1,1,0,2,-2,-3,1,-2,-3,0,1,0,-4,-2,-2,2,1,-1,-8,
		0,-1,2,4,-5,2,3,1,1,-2,-4,0,-3,-6,-1,0,0,-7,-4,-2,3,3,-1,-8,
		-2,-4,-4,-5,12,-5,-5,-3,-3,-2,-6,-5,-5,-4,-3,0,-2,-8,0,-2,-4,-5,-1,-8,
		0,1,1,2,-5,4,2,-1,3,-2,-2,1,-1,-5,0,-1,-1,-5,-4,-2,1,3,-1,-8,
		0,-1,1,3,-5,2,4,0,1,-2,-3,0,-2,-5,-1,0,0,-7,-4,-2,3,3,-1,-8,
		1,-3,0,1,-3,-1,0,5,-2,-3,-4,-2,-3,-5,0,1,0,-7,-5,-1,0,0,-1,-8,
		-1,2,2,1,-3,3,1,-2,6,-2,-2,0,-2,-2,0,-1,-1,-3,0,-2,1,2,-1,-8,
		-1,-2,-2,-2,-2,-2,-2,-3,-2,5,2,-2,2,1,-2,-1,0,-5,-1,4,-2,-2,-1,-8,
		-2,-3,-3,-4,-6,-2,-3,-4,-2,2,6,-3,4,2,-3,-3,-2,-2,-1,2,-3,-3,-1,-8,
		-1,3,1,0,-5,1,0,-2,0,-2,-3,5,0,-5,-1,0,0,-3,-4,-2,1,0,-1,-8,
		-1,0,-2,-3,-5,-1,-2,-3,-2,2,4,0,6,0,-2,-2,-1,-4,-2,2,-2,-2,-1,-8,
		-3,-4,-3,-6,-4,-5,-5,-5,-2,1,2,-5,0,9,-5,-3,-3,0,7,-1,-4,-5,-1,-8,
		1,0,0,-1,-3,0,-1,0,0,-2,-3,-1,-2,-5,6,1,0,-6,-5,-1,-1,0,-1,-8,
		1,0,1,0,0,-1,0,1,-1,-1,-3,0,-2,-3,1,2,1,-2,-3,-1,0,0,-1,-8,
		1,-1,0,0,-2,-1,0,0,-1,0,-2,0,-1,-3,0,1,3,-5,-3,0,0,-1,-1,-8,
		-6,2,-4,-7,-8,-5,-7,-7,-3,-5,-2,-3,-4,0,-6,-2,-5,17,0,-6,-5,-6,-1,-8,
		-3,-4,-2,-4,0,-4,-4,-5,0,-1,-1,-4,-2,7,-5,-3,-3,0,10,-2,-3,-4,-1,-8,
		0,-2,-2,-2,-2,-2,-2,-1,-2,4,2,-2,2,-1,-1,-1,0,-6,-2,4,-2,-2,-1,-8,
		0,-1,2,3,-4,1,3,0,1,-2,-3,1,-2,-4,-1,0,0,-5,-3,-2,3,2,-1,-8,
		0,0,1,3,-5,3,3,0,2,-2,-3,0,-2,-5,0,0,-1,-6,-4,-2,2,3,-1,-8,
		-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-8,
		-8,-8,-8,-8,-8,-8,-8,-8,-8,-8,-8,-8,-8,-8,-8,-8,-8,-8,-8,-8,-8,-8,-8,1
		};
		i = aaFindMatrixIndex(a);
		j = aaFindMatrixIndex(b);
		return PAM250[i][j];
		break;
	}
	default:
		return 0;
		break;
	}
}

double CalculateSimilarity(char* seq2, char* seq1, int windowSize, int matrix)
{
	int i = 0, j = 0;
	int count = 0;
	double similarity;

	for (i = 0; i < windowSize; i++)
	{
		if (aaNonExactMatch(seq1[i], seq2[i], matrix) >= 0 || ('X' == seq1[i] && 'X' == seq2[i]))
		{
			count++;
		}
	}
	similarity = (double)count / (double)windowSize;
	return similarity;
}
double CalculateIdentity(char* seq2, char* seq1, int windowSize)
{
	int i = 0, j = 0;
	int count = 0;
	double identity;

	for (i = 0; i < windowSize; i++)
	{
		if (seq1[i] == seq2[i])
		{
			count++;
		}
	}
	identity = (double)count / (double)windowSize;
	return identity;
}
void Reverse(char* dest, char* sour, int strlen)
{
	int i;
	for (i = 0; i < strlen; i++)
	{
		dest[i] = sour[strlen - 1 - i];
	}
	dest[i] = '\0';
}

void ReverseFun(char* seqArr1, char* seqArr2, double ideSimThr, int windowSize, int aaMatrix, int seqType)
{
	int i = 0, j = 0, n = 0, a = 0;
	int row, col;

	double identityOrSimilarity;
	char* revSeqArr;

	row = strlen(seqArr1);
	col = strlen(seqArr2);

	revSeqArr = (char*)malloc(col * sizeof(char) + 1);
	if (NULL == revSeqArr)
	{
		printf("Unable to dynamically apply memory!\n");
		exit(-1);
	}
	Reverse(revSeqArr, seqArr2, col);

	char* seq1;
	char* seq2;
	seq1 = (char*)malloc(windowSize * sizeof(char) + 1);
	if (NULL == seq1) {
		printf("Unable to dynamically apply memory!\n");
		exit(-1);
	}
	seq2 = (char*)malloc(windowSize * sizeof(char) + 1);
	if (NULL == seq2) {
		printf("Unable to dynamically apply memory!\n");
		exit(-1);
	}
	FILE* pfWrite = fopen("slidingWindowPosition.txt", "w");
	if (0 == seqType)
	{
		for (i = 0; i < row; i++)
		{
			for (j = 0; j < col; j++)
			{
				if (j + windowSize > col)
				{
					break;
				}
				strncpy(seq1, &seqArr1[i], windowSize);
				seq1[windowSize] = '\0';
				strncpy(seq2, &revSeqArr[j], windowSize);
				seq2[windowSize] = '\0';
				identityOrSimilarity = CalculateIdentity(seq2, seq1, windowSize);
				if (identityOrSimilarity >= ideSimThr)
				{
					fprintf(pfWrite, "%d\t%d\n", col-j, i+1);
				}
			}
			if (i + windowSize >= row)
			{
				break;
			}
		}
	}
	else if (1 == seqType)
	{
		for (i = 0; i < row; i++)
		{
			for (j = 0; j < col; j++)
			{
				if (j + windowSize > col)
				{
					break;
				}
				strncpy(seq1, &seqArr1[i], windowSize);
				seq1[windowSize] = '\0';
				strncpy(seq2, &revSeqArr[j], windowSize);
				seq2[windowSize] = '\0';
				identityOrSimilarity = CalculateSimilarity(seq2, seq1, windowSize, aaMatrix);
				if (identityOrSimilarity >= ideSimThr)
				{
					fprintf(pfWrite, "%d\t%d\n", col-j, i+1);
				}
			}
			if (i + windowSize >= row)
			{
				break;
			}
		}
	}
	fclose(pfWrite);

	free(revSeqArr);
	free(seq1);
	free(seq2);
}

void DirectFun(char* seqArr1, char* seqArr2, double ideSimThr, int windowSize, int aaMatrix, int seqType)
{
	int i = 0, j = 0, n = 0, a = 0;
	int row, col;
	double identityOrSimilarity;

	row = strlen(seqArr1);
	col = strlen(seqArr2);

	char* seq1;
	char* seq2;
	seq1 = (char*)malloc(windowSize * sizeof(char) + 1);
	if (NULL == seq1) {
		printf("Unable to dynamically apply memory!\n");
		exit(-1);
	}
	seq2 = (char*)malloc(windowSize * sizeof(char) + 1);
	if (NULL == seq2) {
		printf("Unable to dynamically apply memory!\n");
		exit(-1);
	}

	FILE* pfWrite = fopen("slidingWindowPosition.txt", "w");
	if (0 == seqType)
	{
		for (i = 0; i < row; i++)
		{
			for (j = 0; j < col; j++)
			{
				if (j + windowSize > col)
				{
					break;
				}
				strncpy(seq1, &seqArr1[i], windowSize);
				seq1[windowSize] = '\0';
				strncpy(seq2, &seqArr2[j], windowSize);
				seq2[windowSize] = '\0';
				identityOrSimilarity = CalculateIdentity(seq2, seq1, windowSize);

				if (identityOrSimilarity >= ideSimThr)
				{
					fprintf(pfWrite, "%d\t%d\n", j+1, i+1);
				}
			}
			if (i + windowSize >= row)
			{
				break;
			}
		}
	}
	else if (1 == seqType)
	{
		for (i = 0; i < row; i++)
		{
			for (j = 0; j < col; j++)
			{
				if (j + windowSize > col)
				{
					break;
				}
				strncpy(seq1, &seqArr1[i], windowSize);
				seq1[windowSize] = '\0';
				strncpy(seq2, &seqArr2[j], windowSize);
				seq2[windowSize] = '\0';
				identityOrSimilarity = CalculateSimilarity(seq2, seq1, windowSize, aaMatrix);

				if (identityOrSimilarity >= ideSimThr)
				{
					fprintf(pfWrite, "%d\t%d\n", j+1, i+1);
				}
			}
			if (i + windowSize >= row)
			{
				break;
			}
		}
	}
	fclose(pfWrite);

	free(seq1);
	free(seq2);
}

int main(int argc, char* argv[])
{	
	int seqLengthIndex1 = 0;
	int seqLength1 = 0;
	int c1;
	FILE* fpSingleInputSeq1 = fopen("temp.single.input.fasta1.txt", "r");
	if(!fpSingleInputSeq1)
	{
		perror("File opening failed");
	}

	while ((c1 = fgetc(fpSingleInputSeq1)) != EOF)
	{
		seqLength1++;
	}
	if (ferror(fpSingleInputSeq1))
	{
		puts("I/O error when reading");
	}
	else if (feof(fpSingleInputSeq1))
	{
		;
	}

	char* seqArr1 = (char*)malloc((seqLength1+1) * sizeof(char));
	if (NULL == seqArr1)
	{
		printf("Unable to dynamically apply memory!\n");
		exit(-1);
	}

	rewind(fpSingleInputSeq1);

	while ((c1 = fgetc(fpSingleInputSeq1)) != EOF)
	{
		seqArr1[seqLengthIndex1++] = c1;
	}

	seqArr1[seqLengthIndex1] = '\0';

	if (ferror(fpSingleInputSeq1))
	{
		puts("I/O error when reading");
	}
	else if (feof(fpSingleInputSeq1))
	{
		;
	}

	fclose(fpSingleInputSeq1);

	int seqLengthIndex2 = 0;
	int seqLength2 = 0;
	int c2;
	FILE* fpSingleInputSeq2 = fopen("temp.single.input.fasta2.txt", "r");
	if(!fpSingleInputSeq2)
	{
		perror("File opening failed");
	}

	while ((c2 = fgetc(fpSingleInputSeq2)) != EOF)
	{
		seqLength2++;
	}
	if (ferror(fpSingleInputSeq2))
	{
		puts("I/O error when reading");
	}
	else if (feof(fpSingleInputSeq2))
	{
		;
	}	

	char* seqArr2 = (char*)malloc((seqLength2+1) * sizeof(char));
	if (NULL == seqArr2)
	{
		printf("Unable to dynamically apply memory!\n");
		exit(-1);
	}

	rewind(fpSingleInputSeq2);

	while ((c2 = fgetc(fpSingleInputSeq2)) != EOF)
	{
		seqArr2[seqLengthIndex2++] = c2;
	}

	seqArr2[seqLengthIndex2] = '\0';

	if (ferror(fpSingleInputSeq2))
	{
		puts("I/O error when reading");
	}
	else if (feof(fpSingleInputSeq2))
	{
		;
	}
	fclose(fpSingleInputSeq2);
	
	double ideSimThr = atof(argv[1]);
	int windowSize = atoi(argv[2]);
	int mode = atoi(argv[3]);
	int aaMatrix = atoi(argv[4]);
	int seqType = atoi(argv[5]);

	if (0 == mode)
	{
		DirectFun(seqArr1, seqArr2, ideSimThr, windowSize, aaMatrix, seqType);
	}
	else if (1 == mode)
	{
		ReverseFun(seqArr1, seqArr2, ideSimThr, windowSize, aaMatrix, seqType);
	}

	free(seqArr1);
	free(seqArr2);

	return 0;

	// created by Huilong Chen!
}